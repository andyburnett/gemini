<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Diagram</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 {
            color: #333;
        }
        .mermaid-container { /* Use a specific container class for Mermaid */
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 20px;
            text-align: center;
            width: 80%; /* Give it some width for better visibility */
        }
        /* Make .hidden/.visible apply to the actual container and SVG nodes
           (the diagram is inside `.mermaid-container`, not `.mermaid`).
           Also include a global `.hidden` rule to cover any SVG elements
           that receive the class via JS. */
        .mermaid-container .hidden,
        .hidden {
            visibility: hidden !important;
        }
        .mermaid-container .visible,
        .visible {
            visibility: visible !important;
        }
        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        .node rect, .node circle, .node polygon {
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>Logic Diagram</h1>

    <div class="mermaid-container" id="mermaid-target">
        graph TD
            A[You are here - updated] --> B{Choose a path}
            B --> C[Go to Oberlin]
            B --> D[Go somewhere else]
            C --> E{Decision at Oberlin}
            E --> F[Switch to ED2]
            E --> G[Do not switch to ED2]
    </div>

    <button id="reset-btn">Reset Diagram</button>
    <div id="debug-panel" style="margin-top:16px; width:80%; max-width:900px; font-family:monospace; font-size:12px; white-space:pre-wrap; background:#f7f7f7; padding:8px; border:1px solid #eee; display:none"></div>

    <!-- Mermaid.js for diagrams from markdown-like text -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <script>
        // Map node IDs to their children
        const nodeChildren = {
            'A': ['B'],
            'B': ['C', 'D'],
            'C': ['E'],
            'D': [],
            'E': ['F', 'G'],
            'F': [],
            'G': []
        };

        mermaid.initialize({ startOnLoad: false }); // Explicit control

        const mermaidContainer = document.getElementById('mermaid-target');
        const diagramDefinition = mermaidContainer.textContent.trim(); // Get the diagram definition from the div

        // Render the full diagram once, then control visibility by toggling
        // SVG elements in-place. This avoids brittle re-parsing across
        // Mermaid versions.
        mermaid.render('mermaid-rendered-svg-id', diagramDefinition).then(({ svg }) => {
            mermaidContainer.innerHTML = svg; // Place the rendered SVG into the container
            setupInteractivity();
            dumpDebugInfo();
        }).catch(error => {
            console.error("Mermaid rendering failed:", error);
        });

        function setupInteractivity() {
            const svg = document.querySelector('#mermaid-target svg');

            // 1. Hide all nodes initially
            svg.querySelectorAll('g.node').forEach(node => node.classList.add('hidden'));

            // 2. Tag all edge paths with data attributes for easier tracking
            // Mermaid creates edges with classes like 'flowchart-link'
            Object.keys(nodeChildren).forEach(parentId => {
                nodeChildren[parentId].forEach(childId => {
                    const edge = findAndTagEdge(parentId, childId);
                });
            });

            // 3. Hide all edges initially
            svg.querySelectorAll('path.edge-path, g.edgePath, path[data-edge]').forEach(edge => {
                edge.style.visibility = 'hidden';
            });

            // 4. Show initial nodes ('A' and 'B') and the connecting edge ('A' -> 'B')
            const nodeA = findNodeElement('A');
            const nodeB = findNodeElement('B');

            if (nodeA) nodeA.classList.remove('hidden');
            if (nodeB) nodeB.classList.remove('hidden');

            // Show edge A->B
            showEdgeBetween('A', 'B');

            // Add click handlers that toggle children visibility in-place
            Object.keys(nodeChildren).forEach(nodeId => {
                const nodeElement = findNodeElement(nodeId);
                if (nodeElement) {
                    nodeElement.addEventListener('click', () => toggleChildrenVisibility(nodeId));
                }
            });

            document.getElementById('reset-btn').addEventListener('click', resetDiagram);
        }

        function findNodeElement(id) {
            // Mermaid typically creates a group <g class="node"> with an ID like 'flowchart-ID-...'
            return document.querySelector(`#mermaid-target svg g.node[id*='flowchart-${id}-']`) || document.querySelector(`#mermaid-target svg #${id}`);
        }

        // Find and tag an edge with data attributes for reliable tracking
        function findAndTagEdge(from, to) {
            const svg = document.querySelector('#mermaid-target svg');

            // Try several strategies to find the edge
            const selectors = [
                `g.edgePath[id*='${from}'][id*='${to}']`,
                `g.edgePath[id*='flowchart-${from}-${to}']`,
                `path[id*='flowchart-${from}-${to}']`,
                `path.flowchart-link[id*='${from}'][id*='${to}']`
            ];

            for (const sel of selectors) {
                const el = svg.querySelector(sel);
                if (el) {
                    el.setAttribute('data-edge', `${from}-${to}`);
                    el.setAttribute('data-from', from);
                    el.setAttribute('data-to', to);
                    return el;
                }
            }

            // Fallback: search all paths
            const allPaths = Array.from(svg.querySelectorAll('path'));
            for (const p of allPaths) {
                const id = p.getAttribute('id') || '';
                if (id.includes(from) && id.includes(to)) {
                    p.setAttribute('data-edge', `${from}-${to}`);
                    p.setAttribute('data-from', from);
                    p.setAttribute('data-to', to);
                    return p;
                }
            }

            return null;
        }

        // Show edge between two nodes
        function showEdgeBetween(from, to) {
            const svg = document.querySelector('#mermaid-target svg');

            // Find by data attribute first
            let edge = svg.querySelector(`[data-edge="${from}-${to}"]`);

            // Fallback to finding and tagging
            if (!edge) {
                edge = findAndTagEdge(from, to);
            }

            if (edge) {
                edge.style.visibility = 'visible';

                // Also show parent edgePath group if exists
                if (edge.closest('g.edgePath')) {
                    edge.closest('g.edgePath').style.visibility = 'visible';
                }
            }
        }

        // Hide edge between two nodes
        function hideEdgeBetween(from, to) {
            const svg = document.querySelector('#mermaid-target svg');
            const edge = svg.querySelector(`[data-edge="${from}-${to}"]`);

            if (edge) {
                edge.style.visibility = 'hidden';

                // Also hide parent edgePath group if exists
                if (edge.closest('g.edgePath')) {
                    edge.closest('g.edgePath').style.visibility = 'hidden';
                }
            }
        }

        // Helper: is the element currently visible (not display:none, not visibility:hidden, and not .hidden)
        function isElementVisible(el) {
            if (!el) return false;
            try {
                const cs = getComputedStyle(el);
                if (cs.display === 'none' || cs.visibility === 'hidden') return false;
            } catch (e) {}
            if (el.classList && el.classList.contains('hidden')) return false;
            return true;
        }

        // Recursively hide a node's subtree (used when collapsing a branch)
        function hideSubtree(parentId) {
            const children = nodeChildren[parentId] || [];
            children.forEach(childId => {
                const childNode = findNodeElement(childId);
                if (childNode) childNode.classList.add('hidden');
                hideEdgeBetween(parentId, childId);
                hideSubtree(childId);
            });
        }

        // Ensure edges are visible whenever both their endpoints are visible
        function updateAllEdgesVisibility() {
            Object.keys(nodeChildren).forEach(parentId => {
                nodeChildren[parentId].forEach(childId => {
                    const parentNode = findNodeElement(parentId);
                    const childNode = findNodeElement(childId);
                    if (isElementVisible(parentNode) && isElementVisible(childNode)) {
                        showEdgeBetween(parentId, childId);
                    } else {
                        hideEdgeBetween(parentId, childId);
                    }
                });
            });
            // Update debug panel after changing visibilities
            dumpDebugInfo();
        }

        function dumpDebugInfo() {
            const out = [];
            const svg = document.querySelector('#mermaid-target svg');
            out.push('SVG present: ' + (svg ? 'yes' : 'no'));
            out.push('');
            Object.keys(nodeChildren).forEach(parentId => {
                const node = findNodeElement(parentId);
                const nodeText = node ? (node.id || node.tagName) : 'MISSING';
                const visible = node ? isElementVisible(node) : false;
                const cs = node ? getComputedStyle(node) : {display:'-', visibility:'-'};
                out.push(`NODE ${parentId}: element=${nodeText} display=${cs.display} visibility=${cs.visibility} visible=${visible}`);
                nodeChildren[parentId].forEach(childId => {
                    const child = findNodeElement(childId);
                    const edge = findEdgeElement(parentId, childId);
                    const edgeId = edge ? (edge.id || edge.tagName) : 'MISSING';
                    const edgeDisp = edge && edge.style ? edge.style.display : '-';
                    out.push(`  EDGE ${parentId}->${childId}: element=${edgeId} displayStyle=${edgeDisp} childExists=${!!child}`);
                });
            });

            // list some path ids
            if (svg) {
                const paths = Array.from(svg.querySelectorAll('path')).slice(0,50).map(p=>p.id||p.getAttribute('class')||p.tagName);
                out.push('');
                out.push('Paths (first 50): ' + paths.join(', '));
            }

            const panel = document.getElementById('debug-panel');
            if (panel) { panel.textContent = out.join('\n'); panel.style.display = 'block'; }
        }

        function toggleChildrenVisibility(parentId) {
            const children = nodeChildren[parentId];
            if (!children) return;
            children.forEach(childId => {
                const childNode = findNodeElement(childId);

                if (!childNode) return;

                const currentlyVisible = isElementVisible(childNode);
                if (currentlyVisible) {
                    // collapse: hide child and its subtree, hide connecting edge
                    childNode.classList.add('hidden');
                    hideEdgeBetween(parentId, childId);
                    hideSubtree(childId);
                } else {
                    // expand: show child and show edge if parent is visible
                    childNode.classList.remove('hidden');
                    const parentNode = findNodeElement(parentId);
                    if (isElementVisible(parentNode)) {
                        showEdgeBetween(parentId, childId);
                    }
                }

                // Keep global edge visibility consistent
                updateAllEdgesVisibility();
            });
        }

        function resetDiagram() {
            const svg = document.querySelector('#mermaid-target svg');

            // Hide all nodes
            svg.querySelectorAll('g.node').forEach(node => node.classList.add('hidden'));

            // Hide all edges
            svg.querySelectorAll('path.edge-path, g.edgePath, path[data-edge]').forEach(edge => {
                edge.style.visibility = 'hidden';
            });

            // Show initial nodes ('A' and 'B') and connecting edge ('A' -> 'B')
            const nodeA = findNodeElement('A');
            const nodeB = findNodeElement('B');

            if (nodeA) nodeA.classList.remove('hidden');
            if (nodeB) nodeB.classList.remove('hidden');

            // Show edge A->B
            showEdgeBetween('A', 'B');
        }
    </script>

</body>
</html>
